#include "UnityCG.cginc"

// Kernels
//
#pragma kernel RLDiffuseAlpha
#pragma kernel RLHDRPMask
#pragma kernel RLURPMetallicGloss
#pragma kernel RLGradient
#pragma kernel RLMagicaWeightMap
//
#pragma kernel RLDiffuseBlend
#pragma kernel RLMask
#pragma kernel RLDetailMask
#pragma kernel RLNormalBlend
#pragma kernel RLHeadDiffuse
#pragma kernel RLHeadMask
#pragma kernel RLSkinMask
#pragma kernel RLHeadWrinkleSmoothnessPack
#pragma kernel RLHeadWrinkleFlowPack
#pragma kernel RLHeadMetallicGloss
#pragma kernel RLSkinMetallicGloss
#pragma kernel RLHeadAO
#pragma kernel RLSkinAO
#pragma kernel RLHeadSubsurface
#pragma kernel RLSkinSubsurface
#pragma kernel RLHeadNormal
#pragma kernel RLSkinNormal
#pragma kernel RLDetail
#pragma kernel RLSubsurface
#pragma kernel RLThickness
#pragma kernel RLTeethDiffuse
#pragma kernel RLTeethMask
#pragma kernel RLTeethMetallicGloss
#pragma kernel RLTeethAO
#pragma kernel RLTeethSubsurface
#pragma kernel RLTeethThickness
#pragma kernel RLTongueDiffuse
#pragma kernel RLTongueMask
#pragma kernel RLTongueMetallicGloss
#pragma kernel RLTongueAO
#pragma kernel RLCorneaDiffuse
#pragma kernel RLEyeDiffuse
#pragma kernel RLCorneaSingleDiffuse
#pragma kernel RLCorneaMask
#pragma kernel RLCorneaDetailMask
#pragma kernel RLCorneaMetallicGloss
#pragma kernel RLCorneaAO
#pragma kernel RLEyeMask
#pragma kernel RLCorneaThickness
#pragma kernel RLCorneaSubsurfaceMask
#pragma kernel RLHairColoredDiffuse
#pragma kernel RLHairColoredDiffuseOnly
#pragma kernel RLHairDiffuse
#pragma kernel RLHairMask
#pragma kernel RLHairMetallicGloss
#pragma kernel RLHairAO
#pragma kernel RLEyeOcclusionDiffuse
#pragma kernel RLFlowToNormal
#pragma kernel RLHDRPCorrected

#pragma kernel RLChannelPackLinear
#pragma kernel RLChannelPackSymmetryLinear

#pragma multi_compile _ _MAC_OS

// Defines
//
#define SAMPLE(tex,coord) tex.SampleLevel (sampler##tex,coord, 0)
#define SAMPLE_NORMAL(tex, coord) UnpackNormal(tex.SampleLevel (sampler##tex,coord, 0))
#define UPACK(comp) (min(1.0, max(0.0, (comp + 1.0) * 0.5)))
#define INVERTED_SCALE(val, fac) (1.0 - ((1.0 - val) * fac))
#define INVERTED_POWER_SCALE(val, power, fac) (1.0 - ((1.0 - pow(val, power)) * fac))
#define RADIAL(uv) (length(uv - float2(0.5, 0.5)))
#define HSV(c, h, s, v) (Saturation_float3(Hue_float3(c, h), s) * v)
#define SV(c, s, v) (Saturation_float3(c, s) * v)
#define TEX2D(tex) Texture2D<float4>tex; SamplerState sampler##tex


// Compute Shader Output
//
RWTexture2D<float4> Result;

// Compute Shader Inputs
//
TEX2D(Diffuse);
float4 diffuseColor;
TEX2D(ColorBlend);
float colorBlendStrength;

TEX2D(Normal);
TEX2D(NormalBlend);
float normalStrength;
float normalBlendStrength;
float sssNormalSoften;

TEX2D(Mask);
TEX2D(Detail);
TEX2D(MetallicGloss);
TEX2D(AO);
TEX2D(Metallic);
TEX2D(Roughness);
TEX2D(Alpha);
TEX2D(MicroNormalMask);
TEX2D(SmoothnessLUT);

TEX2D(Roughness1);
TEX2D(Roughness2);
TEX2D(Roughness3);

TEX2D(Flow1);
TEX2D(Flow2);
TEX2D(Flow3);

TEX2D(CavityAO);
float smoothnessMin, smoothnessMax, smoothnessPower;
float aoStrength;
float mouthAOPower, nostrilAOPower, lipsAOPower;

TEX2D(RGBAMask);
TEX2D(NMUILMask);
TEX2D(CFULCMask);
TEX2D(EarNeckMask);
float microSmoothnessMod;
float rMSM, gMSM, bMSM, aMSM;
float noseMSM;
float mouthMSM;
float upperLidMSM;
float innerLidMSM;
float earMSM;
float neckMSM;
float cheekMSM;
float foreheadMSM;
float upperLipMSM;
float chinMSM;
float unmaskedMSM;
float rSS, gSS, bSS, aSS;
float noseSS;
float mouthSS;
float upperLidSS;
float innerLidSS;
float earSS;
float neckSS;
float cheekSS;
float foreheadSS;
float upperLipSS;
float chinSS;
float unmaskedSS;

TEX2D(MicroNormal);
float microNormalStrength;

TEX2D(BaseMap);
TEX2D(Subsurface);
float subsurfaceScale;
TEX2D(Thickness);
float thicknessScale;
float thicknessScaleMin;
float4 subsurfaceFalloff;
float invertMap;

TEX2D(GradientAO);
TEX2D(GumsMask);
float frontAO;
float rearAO;
float smoothnessFront, smoothnessRear;
float gumsSaturation, gumsBrightness;
float teethSaturation, teethBrightness;
float tongueSaturation, tongueBrightness;
float gumsSSS, teethSSS, tongueSSS;
float gumsThickness, teethThickness, tongueThickness;
float isUpperTeeth;

TEX2D(ScleraDiffuse);
TEX2D(CorneaDiffuse);
float irisScale, irisHue, irisSaturation, irisBrightness;
float scleraScale, scleraHue, scleraSaturation, scleraBrightness;
float pupilScale;
float irisRadius, limbusWidth;
float limbusDarkRadius, limbusDarkWidth;
float shadowRadius, shadowHardness;
float4 cornerShadowColor, limbusColor, irisColor, irisCloudyColor;
float depthRadius;
float corneaSmoothness, scleraSmoothness, irisSmoothness;
float scleraSubsurfaceScale, irisSubsurfaceScale;
float parallaxRadius;

TEX2D(Flow);
TEX2D(ID);
TEX2D(Root);
TEX2D(Specular);
float4 baseColor, vertexBaseColor;
float vertexColorStrength, baseColorStrength, diffuseStrength, alphaPower, alphaRemap;
float globalStrength, rootColorStrength, endColorStrength, invertRootMap;
float highlightBlend;
float3 highlightADistribution, highlightBDistribution;
float highlightAStrength, highlightAOverlapEnd, highlightAOverlapInvert;
float highlightBStrength, highlightBOverlapEnd, highlightBOverlapInvert;
float4 rootColor, endColor, highlightAColor, highlightBColor;
float aoOccludeAll;
float3 tangentVector;
float tangentFlipY;

float eoInnerMin, eoInnerMax, eoOuterMin, eoOuterMax;
float eoTopMin, eoTopMax, eoTopCurve, eoBottomMin, eoBottomMax, eoBottomCurve;
float eoOcclusionStrength, eoTop2Min, eoTop2Max, eoOcclusionStrength2;
float eoTearDuctPosition, eoTearDuctWidth, eoOcclusionPower;
float4 eoEyeOcclusionColor;    

TEX2D(RedChannel);
TEX2D(GreenChannel);
TEX2D(BlueChannel);
TEX2D(AlphaChannel);

TEX2D(RedChannelL);
TEX2D(GreenChannelL);
TEX2D(BlueChannelL);
TEX2D(AlphaChannelL);

TEX2D(RedChannelR);
TEX2D(GreenChannelR);
TEX2D(BlueChannelR);
TEX2D(AlphaChannelR);

float4 redMaskL;
float4 greenMaskL;
float4 blueMaskL;
float4 alphaMaskL;

float4 redMaskR;
float4 greenMaskR;
float4 blueMaskR;
float4 alphaMaskR;

TEX2D(WeightMap);
float threshold;

// Node functions
//
float4 BlendOverlay_float4(float4 Base, float4 Blend, float Opacity)
{
    float4 result1 = 1.0 - 2.0 * (1.0 - Base) * (1.0 - Blend);
    float4 result2 = 2.0 * Base * Blend;
    float4 zeroOrOne = step(Base, 0.5);
    float4 Out = result2 * zeroOrOne + (1 - zeroOrOne) * result1;
    return lerp(Base, Out, Opacity);
}

float4 BlendMultiply_float4(float4 Base, float4 Blend, float Opacity)
{
    float4 Out = Base * Blend;
    return lerp(Base, Out, Opacity);    
}

float4 BlendOverwrite_float4(float4 Base, float4 Blend, float Opacity)
{    
    return lerp(Base, Blend, Opacity);
}

void NormalStrength_float3(float3 In, float Strength, out float3 Out)
{
    Out = float3(In.rg * Strength, lerp(1, In.b, saturate(Strength)));
}

void NormalBlend_float3(float3 A, float3 B, out float3 Out)
{        
    Out = normalize(float3(A.rg + B.rg, A.b * B.b));
}

void NormalBlendReoriented_float3(float3 A, float3 B, out float3 Out)
{
    float3 t = A.xyz + float3(0.0, 0.0, 1.0);
    float3 u = B.xyz * float3(-1.0, -1.0, 1.0);
    Out = (t / t.z) * dot(t, u) - u;
}


float3 Hue_float3(float3 In, float Offset)
{
    // this expects the hue offset in normalized form i.e. 0.0 - 1.0, with 0.5 being no offset.
    Offset = Offset * 360.0 - 180.0;
    float4 K = float4(0.0, -1.0 / 3.0, 2.0 / 3.0, -1.0);
    float4 P = lerp(float4(In.bg, K.wz), float4(In.gb, K.xy), step(In.b, In.g));
    float4 Q = lerp(float4(P.xyw, In.r), float4(In.r, P.yzx), step(P.x, In.r));
    float D = Q.x - min(Q.w, Q.y);
    float E = 1e-10;
    float3 hsv = float3(abs(Q.z + (Q.w - Q.y) / (6.0 * D + E)), D / (Q.x + E), Q.x);

    float hue = hsv.x + Offset / 360.0;
    hsv.x = (hue < 0)
        ? hue + 1
        : (hue > 1)
        ? hue - 1
        : hue;

    float4 K2 = float4(1.0, 2.0 / 3.0, 1.0 / 3.0, 3.0);
    float3 P2 = abs(frac(hsv.xxx + K2.xyz) * 6.0 - K2.www);
    return hsv.z * lerp(K2.xxx, saturate(P2 - K2.xxx), hsv.y);
}

float3 Saturation_float3(float3 In, float Saturation)
{
    float luma = dot(In, float3(0.2126729, 0.7151522, 0.0721750));
    return luma.xxx + Saturation.xxx * (In - luma.xxx);
}

float Remap_float(float In, float InMin, float InMax, float OutMin, float OutMax)
{
    return OutMin + (In - InMin) * (OutMax - OutMin) / (InMax - InMin);
}

float2 TilingOffset(float2 uv, float scale, float2 offset)
{
    float tilingScale = 1.0 / scale;
    float2 tilingOffset = (1.0 - tilingScale) * offset;
    return uv * tilingScale + tilingOffset;
}
 
/* for reference...
fixed3 UnpackNormal(fixed4 packednormal)
{
#if defined(SHADER_API_GLES) || defined(SHADER_API_MOBILE)
    return packednormal.xyz * 2 - 1;
#else
    fixed3 normal;
    normal.xy = packednormal.wy * 2 - 1;
    normal.z = sqrt(1 - normal.x * normal.x - normal.y * normal.y);
    return normal;
#endif
}*/

float4 PackNormal(float3 n)
{
    return float4(UPACK(n), 1.0);
}

/*
half4 LinearTosRGB(half4 linRGB)
{
    linRGB = max(linRGB, half4(0.h, 0.h, 0.h, 0.h));    
    return half4((max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h)).xyzw);
}

half LinearTosRGB(half lin)
{
    lin = max(lin, 0.0h);
    return max(1.055h * pow(lin, 0.416666667h) - 0.055h, 0.h);
}

*/


float4 LinearTosRGB(float4 In)
{
#ifdef UNITY_COLORSPACE_GAMMA    
    return In; 
#elif _MAC_OS
    return In;
#else
    float3 sRGBLo = In.xyz * 12.92;
    float3 sRGBHi = (pow(max(abs(In.xyz), 1.192092896e-07), float3(1.0 / 2.4, 1.0 / 2.4, 1.0 / 2.4)) * 1.055) - 0.055;
    float3 sRGB = float3(In.xyz <= 0.0031308) ? sRGBLo : sRGBHi;
    return float4(sRGB, In.a);
#endif
}

float LinearTosRGB(float In)
{
#if UNITY_COLORSPACE_GAMMA
    return In;
#else
    float sRGBLo = In * 12.92;
    float sRGBHi = (pow(max(abs(In), 1.192092896e-07), 1.0 / 2.4) * 1.055) - 0.055;
    return In <= 0.0031308 ? sRGBLo : sRGBHi;
#endif
}

float4 sRGBToLinear(float4 In)
{
#if UNITY_COLORSPACE_GAMMA
    return In;
#else
    float3 linRGBLo = In.rgb / 12.92;;
    float3 linRGBHi = pow(max(abs((In.rgb + 0.055) / 1.055), 1.192092896e-07), float3(2.4, 2.4, 2.4));
    float3 lin = float3(In.rgb <= 0.04045) ? linRGBLo : linRGBHi;
    return float4(lin, In.a);
#endif
}

half4 LinearTosRGBApprox(half4 In)
{
#if UNITY_COLORSPACE_GAMMA
    return In;
#else
    half3 linRGB = max(In.rgb, half3(0.h, 0.h, 0.h));
    linRGB = max(1.055h * pow(linRGB, 0.416666667h) - 0.055h, 0.h);
    return float4(linRGB, In.a);
#endif
}

half4 sRGBToLinearApprox(half4 In)
{
#if UNITY_COLORSPACE_GAMMA
    return In;
#else
    half3 sRGB = In.rgb;
    sRGB = sRGB * (sRGB * (sRGB * 0.305306011h + 0.682171111h) + 0.012522878h);
    return float4(sRGB, In.a);
#endif
}

float sRGBToLinear(float In)
{
#if UNITY_COLORSPACE_GAMMA
    return In;
#else
    float linearRGBLo = In / 12.92;
    float linearRGBHi = pow(max(abs((In + 0.055) / 1.055), 1.192092896e-07), 2.4);
    return In <= 0.04045 ? linearRGBLo : linearRGBHi;
#endif
}

float2 GetUV(int2 xy)
{
    int w, h;
    Result.GetDimensions(w, h);
    return float2(float(xy.x + 0.5) / float(w), float(xy.y + 0.5) / float(h));
}

float invLerp(float a, float b, float v) 
{
    return (v - a) / (b - a);
}








[numthreads(1, 1, 1)]
void RLChannelPackLinear(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float redChannel = SAMPLE(RedChannel, uv).g;
    float greenChannel = SAMPLE(GreenChannel, uv).g;
    float blueChannel = SAMPLE(BlueChannel, uv).g;
    float alphaChannel = SAMPLE(AlphaChannel, uv).g;    

    float4 packed = float4(redChannel, greenChannel, blueChannel, alphaChannel);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLChannelPackSymmetryLinear(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 redChannelL = SAMPLE(RedChannelL, uv);
    float4 greenChannelL = SAMPLE(GreenChannelL, uv);
    float4 blueChannelL = SAMPLE(BlueChannelL, uv);
    float4 alphaChannelL = SAMPLE(AlphaChannelL, uv);

    float4 redChannelR = SAMPLE(RedChannelR, uv);
    float4 greenChannelR = SAMPLE(GreenChannelR, uv);
    float4 blueChannelR = SAMPLE(BlueChannelR, uv);
    float4 alphaChannelR = SAMPLE(AlphaChannelR, uv);

    float redL = dot(redChannelL, redMaskL);
    float redR = dot(redChannelR, redMaskR);

    float greenL = dot(greenChannelL, greenMaskL);
    float greenR = dot(greenChannelR, greenMaskR);

    float blueL = dot(blueChannelL, blueMaskL);
    float blueR = dot(blueChannelR, blueMaskR);

    float alphaL = dot(alphaChannelL, alphaMaskL);
    float alphaR = dot(alphaChannelR, alphaMaskR);

    float4 packed = float4(saturate(redL+redR),
        saturate(greenL+greenR),
        saturate(blueL+blueR),
        saturate(alphaL+alphaR));

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLGradient(uint3 id : SV_DispatchThreadID)
{
    int w, h;
    Result.GetDimensions(w, h);
    //float v = (id.x / float(w - 1)) + (id.y / float(h - 1));
    float v = (id.x / float(w - 1));

    Result[id.xy] = float4(v, v, v, 1);
}

[numthreads(1, 1, 1)]
void RLMagicaWeightMap(uint3 id : SV_DispatchThreadID)
{
    int w, h;
    Result.GetDimensions(w, h);
    float2 uv = GetUV(id.xy);
    
    float weight = SAMPLE(WeightMap, uv).r;
    // float threshold;

    // red = static
    float r = weight <= threshold ? 1 : 0;
    // green = can move
    float g = weight > threshold ? 1 : 0;
    // blue = obey limit
    float b = weight >= threshold ? weight : 0;

    Result[id.xy] = float4(r, g, b, 1);
}

// Generic Bake kernels
//
[numthreads(1, 1, 1)]
void RLDiffuseBlend(uint3 id : SV_DispatchThreadID)
{    
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float4 colorBlend = SAMPLE(ColorBlend, uv);

    float4 ob = BlendOverlay_float4(diffuse, colorBlend, colorBlendStrength);

    Result[id.xy] = LinearTosRGB(ob);
}

[numthreads(1, 1, 1)]
void RLMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLDiffuseAlpha(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float alpha = SAMPLE(Alpha, uv).g;
    float4 packed = float4(diffuse.rgb, alpha);

    Result[id.xy] = LinearTosRGB(packed);
}

[numthreads(1, 1, 1)]
void RLHDRPMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float metallic = SAMPLE(Metallic, uv).g;
    float ao = SAMPLE(AO, uv).g;
    float roughness = SAMPLE(Roughness, uv).g;
    roughness = (roughness * 255.0 / 256.0) + (0.5 / 256.0);
    float smoothness = SAMPLE(SmoothnessLUT, float2(roughness, roughness)).g;
    float detailMask = SAMPLE(MicroNormalMask, uv).g;    
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLURPMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float metallic = SAMPLE(Metallic, uv).g;
    float roughness = SAMPLE(Roughness, uv).g;
    roughness = (roughness * 255.0 / 256.0) + (0.5 / 256.0);
    float smoothness = SAMPLE(SmoothnessLUT, float2(roughness, roughness)).g;
    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLNormalBlend(uint3 id : SV_DispatchThreadID)
{        
    float2 uv = GetUV(id.xy);

    float3 normal = SAMPLE_NORMAL(Normal, uv);
    float3 normalBlend = SAMPLE_NORMAL(NormalBlend, uv);

    float3 mn, bn, on;
    NormalStrength_float3(normal, normalStrength, mn);
    NormalStrength_float3(normalBlend, normalBlendStrength, bn);
    NormalBlend_float3(mn, bn, on);   

    Result[id.xy] = PackNormal(on);
}

[numthreads(1, 1, 1)]
void RLNormal(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float3 normal = SAMPLE_NORMAL(Normal, uv);
    float3 normalBlend = SAMPLE_NORMAL(NormalBlend, uv);

    float3 mn;
    NormalStrength_float3(normal, normalStrength, mn);
    
    Result[id.xy] = PackNormal(mn);
}

[numthreads(1, 1, 1)]
void RLDetail(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float3 microNormal = SAMPLE_NORMAL(MicroNormal, uv);

    float4 packed;
    packed.xz = 0.5;
    packed.wy = UPACK(microNormal.xy); 

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLDetailMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);

    float detailMask = mask.b;
    float4 packed = float4(detailMask, detailMask, detailMask, detailMask);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLSubsurface(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 subsurface = subsurfaceScale * SAMPLE(Subsurface, uv) * SAMPLE(BaseMap, uv);

    subsurface.a = 1.0;

    Result[id.xy] = subsurface;
}

[numthreads(1, 1, 1)]
void RLThickness(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 thickness = SAMPLE(Thickness, uv);
    thickness = lerp(thickness, 1.0 - thickness, invertMap);    
    thickness = saturate(lerp(thicknessScaleMin, thicknessScale, thickness));
    thickness *= subsurfaceFalloff * SAMPLE(BaseMap, uv);
    thickness.a = 1.0;

    Result[id.xy] = thickness;
}

// Skin and Head Bake Kernels
//
void HeadSmoothnessScatterMask(float2 uv, out float ScatterMask, out float SmoothnessMod)
{
    float4 In1 = SAMPLE(NMUILMask, uv);
    float4 In2 = SAMPLE(CFULCMask, uv);
    float4 In3 = SAMPLE(EarNeckMask, uv);
    In3.zw = 0;
    float4 Mod1 = float4(noseMSM, mouthMSM, upperLidMSM, innerLidMSM);
    float4 Mod2 = float4(cheekMSM, foreheadMSM, upperLipMSM, chinMSM);
    float4 Mod3 = float4(neckMSM, earMSM, 0.0, 0.0);
    float4 Scatter1 = float4(noseSS, mouthSS, upperLidSS, innerLidSS);
    float4 Scatter2 = float4(cheekSS, foreheadSS, upperLipSS, chinSS);
    float4 Scatter3 = float4(neckSS, earSS, 0.0, 0.0);

    float4 m = In1 + In2 + In3;
    float mask = saturate(m.x + m.y + m.z + m.w);
    float unmask = 1.0 - mask;

    SmoothnessMod = dot(In1, Mod1) + dot(In2, Mod2) + dot(In3, Mod3) + (unmask * unmaskedMSM);
    ScatterMask = dot(In1, Scatter1) + dot(In2, Scatter2) + dot(In3, Scatter3) + (unmask * unmaskedSS);
}

float HeadSmoothnessMod(float2 uv)
{
    float4 In1 = SAMPLE(NMUILMask, uv);
    float4 In2 = SAMPLE(CFULCMask, uv);
    float4 In3 = SAMPLE(EarNeckMask, uv);
    float4 Mod1 = float4(noseMSM, mouthMSM, upperLidMSM, innerLidMSM);
    float4 Mod2 = float4(cheekMSM, foreheadMSM, upperLipMSM, chinMSM);
    float4 Mod3 = float4(neckMSM, earMSM, 0.0, 0.0);
    
    float4 m = In1 + In2 + In3;
    float mask = saturate(m.x + m.y + m.z + m.w);
    float unmask = 1.0 - mask;

    return dot(In1, Mod1) + dot(In2, Mod2) + dot(In3, Mod3) + (unmask * unmaskedMSM);
}

float HeadScatterMask(float2 uv)
{
    float4 In1 = SAMPLE(NMUILMask, uv);
    float4 In2 = SAMPLE(CFULCMask, uv);
    float4 In3 = SAMPLE(EarNeckMask, uv);
    In3.zw = 0.0;
    float4 Scatter1 = float4(noseSS, mouthSS, upperLidSS, innerLidSS);
    float4 Scatter2 = float4(cheekSS, foreheadSS, upperLipSS, chinSS);
    float4 Scatter3 = float4(neckSS, earSS, 0.0, 0.0);

    float4 m = In1 + In2 + In3;
    float mask = saturate(m.x + m.y + m.z + m.w);
    float unmask = 1.0 - mask;

    return dot(In1, Scatter1) + dot(In2, Scatter2) + dot(In3, Scatter3) + (unmask * unmaskedSS);
}

void SkinSmoothnessScatterMask(float2 uv, out float ScatterMask, out float SmoothnessMod)
{
    float4 In1 = SAMPLE(RGBAMask, uv);
    float4 Mod1 = float4(rMSM, gMSM, bMSM, aMSM);
    float4 Scatter1 = float4(rSS, gSS, bSS, aSS);
    
    float mask = saturate(In1.r + In1.g + In1.b + In1.a);
    float unmask = 1.0 - mask;
    
    SmoothnessMod = dot(In1, Mod1) + (unmask * unmaskedMSM);
    ScatterMask = dot(In1, Scatter1) + (unmask * unmaskedSS);
}

float SkinSmoothnessMod(float2 uv)
{
    float4 In1 = SAMPLE(RGBAMask, uv);
    float4 Mod1 = float4(rMSM, gMSM, bMSM, aMSM);    

    float mask = saturate(In1.r + In1.g + In1.b + In1.a);
    float unmask = 1.0 - mask;
    
    return dot(In1, Mod1) + (unmask * unmaskedMSM);
}

float SkinScatterMask(float2 uv)
{
    float4 In1 = SAMPLE(RGBAMask, uv);    
    float4 Scatter1 = float4(rSS, gSS, bSS, aSS);

    float mask = saturate(In1.r + In1.g + In1.b + In1.a);
    float unmask = 1.0 - mask;
    
    return dot(In1, Scatter1) + (unmask * unmaskedSS);
}

float HeadCavityAO(float2 uv)
{
    float4 cavityAO = SAMPLE(CavityAO, uv);

    float mouthAO = pow(cavityAO.g, mouthAOPower);
    float nostrilAO = pow(cavityAO.b, nostrilAOPower);
    float lipsAO = pow(cavityAO.a, lipsAOPower);    
    return saturate(mouthAO * nostrilAO * lipsAO);
}

[numthreads(1, 1, 1)]
void RLHeadDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float alpha = diffuse.a;
    float4 colorBlend = SAMPLE(ColorBlend, uv);

    float cavityAO = HeadCavityAO(uv);
    float4 ob = BlendOverlay_float4(diffuse, colorBlend, colorBlendStrength);
    float4 cavityBlend = ob * cavityAO;
    cavityBlend.a = alpha;

    Result[id.xy] = LinearTosRGB(cavityBlend);
}

[numthreads(1, 1, 1)]
void RLHeadMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float cavityAO = HeadCavityAO(uv);
    float smoothnessMod = HeadSmoothnessMod(uv);
    float microScatteringMultiplier = HeadScatterMask(uv) * subsurfaceScale;
    float subsurface = SAMPLE(Subsurface, uv).y * microScatteringMultiplier;
    subsurface = saturate(subsurface * microScatteringMultiplier);
    float subsurfaceFlattenNormals = saturate(1.0 - (subsurface * subsurface * sssNormalSoften));

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength) * cavityAO;
    //float detailMask = mask.b * subsurfaceFlattenNormals;
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness);
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHeadWrinkleFlowPack(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    
    float flow1 = SAMPLE(Flow1, uv).g;
    float flow2 = SAMPLE(Flow2, uv).g;
    float flow3 = SAMPLE(Flow3, uv).g;        
    
    float4 packed = float4(flow1, flow2, flow3, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHeadWrinkleSmoothnessPack(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    
    float smoothness1 = saturate(1.0 - SAMPLE(Roughness1, uv).g);
    float smoothness2 = saturate(1.0 - SAMPLE(Roughness2, uv).g);
    float smoothness3 = saturate(1.0 - SAMPLE(Roughness3, uv).g);
    float smoothnessMod = HeadSmoothnessMod(uv);    
    
    smoothness1 = lerp(smoothnessMin, smoothnessMax, pow(smoothness1, smoothnessPower));
    smoothness1 = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness1);

    smoothness2 = lerp(smoothnessMin, smoothnessMax, pow(smoothness2, smoothnessPower));
    smoothness2 = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness2);

    smoothness3 = lerp(smoothnessMin, smoothnessMax, pow(smoothness3, smoothnessPower));
    smoothness3 = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness3);
    
    float4 packed = float4(smoothness1, smoothness2, smoothness3, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLSkinMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float smoothnessMod = SkinSmoothnessMod(uv);
    float microScatteringMultiplier = SkinScatterMask(uv) * subsurfaceScale;
    float subsurface = SAMPLE(Subsurface, uv).y * microScatteringMultiplier;
    subsurface = saturate(subsurface * microScatteringMultiplier);
    float subsurfaceFlattenNormals = saturate(1.0 - (subsurface * subsurface * sssNormalSoften));

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    //float detailMask = mask.b * subsurfaceFlattenNormals;
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness);
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHeadMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float cavityAO = HeadCavityAO(uv);
    float smoothnessMod = HeadSmoothnessMod(uv);
    float microScatteringMultiplier = HeadScatterMask(uv) * subsurfaceScale;
    float subsurface = SAMPLE(Subsurface, uv).y * microScatteringMultiplier;
    subsurface = saturate(subsurface * microScatteringMultiplier);
    float subsurfaceFlattenNormals = saturate(1.0 - (subsurface * subsurface * sssNormalSoften));

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength) * cavityAO;
    //float detailMask = mask.b * subsurfaceFlattenNormals;
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness);
    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLSkinMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float smoothnessMod = SkinSmoothnessMod(uv);
    float microScatteringMultiplier = SkinScatterMask(uv) * subsurfaceScale;
    float subsurface = SAMPLE(Subsurface, uv).y * microScatteringMultiplier;
    subsurface = saturate(subsurface * microScatteringMultiplier);
    float subsurfaceFlattenNormals = saturate(1.0 - (subsurface * subsurface * sssNormalSoften));

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    //float detailMask = mask.b * subsurfaceFlattenNormals;
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness);
    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHeadAO(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float cavityAO = HeadCavityAO(uv);
    float smoothnessMod = HeadSmoothnessMod(uv);

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength) * cavityAO;
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness);
    float4 packed = float4(ao, ao, ao, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLSkinAO(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float smoothnessMod = SkinSmoothnessMod(uv);

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = saturate((1.0 + smoothnessMod + microSmoothnessMod) * smoothness);
    float4 packed = float4(ao, ao, ao, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHeadSubsurface(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    float scatterMask = HeadScatterMask(uv);

    float4 subsurface = saturate(scatterMask * subsurfaceScale) * SAMPLE(Subsurface, uv) * subsurfaceFalloff * SAMPLE(BaseMap, uv);

    subsurface.a = 1.0;

    Result[id.xy] = saturate(subsurface);
}

[numthreads(1, 1, 1)]
void RLSkinSubsurface(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    float scatterMask = SkinScatterMask(uv);

    float4 subsurface = saturate(scatterMask * subsurfaceScale) * SAMPLE(Subsurface, uv) * subsurfaceFalloff * SAMPLE(BaseMap, uv);

    subsurface.a = 1.0;

    Result[id.xy] = saturate(subsurface);
}

[numthreads(1, 1, 1)]
void RLHeadNormal(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float3 normal = SAMPLE_NORMAL(Normal, uv);
    float3 normalBlend = SAMPLE_NORMAL(NormalBlend, uv);
    float microScatteringMultiplier = HeadScatterMask(uv) * subsurfaceScale;
    float subsurface = SAMPLE(Subsurface, uv).y * microScatteringMultiplier;
    float subsurfaceFlattenNormals = saturate(1.0 - (subsurface * subsurface * sssNormalSoften));    

    float3 mn, bn, on;
    //NormalStrength_float3(normal, normalStrength * subsurfaceFlattenNormals, mn);
    //NormalStrength_float3(normalBlend, normalBlendStrength * subsurfaceFlattenNormals, bn);
    NormalStrength_float3(normal, normalStrength, mn);
    NormalStrength_float3(normalBlend, normalBlendStrength, bn);
    NormalBlend_float3(mn, bn, on);

    Result[id.xy] = PackNormal(on);
}

[numthreads(1, 1, 1)]
void RLSkinNormal(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float3 normal = SAMPLE_NORMAL(Normal, uv);
    float3 normalBlend = SAMPLE_NORMAL(NormalBlend, uv);
    float microScatteringMultiplier = SkinScatterMask(uv) * subsurfaceScale;
    float subsurface = SAMPLE(Subsurface, uv).y * microScatteringMultiplier;
    float subsurfaceFlattenNormals = saturate(1.0 - (subsurface * subsurface * sssNormalSoften));

    float3 ns; 
    //NormalStrength_float3(normal, normalStrength * subsurfaceFlattenNormals, ns);
    NormalStrength_float3(normal, normalStrength, ns);

    Result[id.xy] = PackNormal(ns);
}

// Teeth and Tongue Bake Kernels
//
[numthreads(1, 1, 1)]
void RLTeethDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);
    float4 gumsMask = SAMPLE(GumsMask, uv);    

    float cavityMask = lerp(gradientAO.r, gradientAO.g, isUpperTeeth);    
    float3 gums = SV(diffuse, gumsSaturation, gumsBrightness);
    float3 teeth = SV(diffuse, teethSaturation, teethBrightness);
    float4 teethGums = float4(lerp(gums, teeth, gumsMask.g), 1.0);
    float4 baseColor = lerp(teethGums * rearAO, teethGums * frontAO, cavityMask);
    baseColor.a = diffuse.a;

    Result[id.xy] = LinearTosRGB(baseColor);
}

[numthreads(1, 1, 1)]
void RLTeethMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = lerp(gradientAO.r, gradientAO.g, isUpperTeeth);
    
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessFront, smoothnessMax, mask.a);
    smoothness = lerp(smoothnessRear, smoothness, cavityMask);
    smoothness = pow(saturate(smoothness), smoothnessPower);

    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLTeethMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = lerp(gradientAO.r, gradientAO.g, isUpperTeeth);

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessFront, smoothnessMax, mask.a);
    smoothness = lerp(smoothnessRear, smoothness, cavityMask);
    smoothness = pow(saturate(smoothness), smoothnessPower);

    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLTeethAO(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = lerp(gradientAO.r, gradientAO.g, isUpperTeeth);

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessFront, smoothnessMax, mask.a);
    smoothness = lerp(smoothnessRear, smoothness, cavityMask);
    smoothness = pow(saturate(smoothness), smoothnessPower);

    float4 packed = float4(ao, ao, ao, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLTeethSubsurface(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
        
    float4 gumsMask = SAMPLE(GumsMask, uv);
        
    float4 subsurface = float4(lerp(gumsSSS.xxx, teethSSS.xxx, gumsMask.g), 1.0) * 
                                subsurfaceFalloff * SAMPLE(BaseMap, uv);

    Result[id.xy] = subsurface;
}

[numthreads(1, 1, 1)]
void RLTeethThickness(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    
    float4 gumsMask = SAMPLE(GumsMask, uv);

    float4 thickness = float4(lerp(gumsThickness.xxx, teethThickness.xxx, gumsMask.g), 1.0) *
                                subsurfaceFalloff * SAMPLE(BaseMap, uv);

    Result[id.xy] = thickness;
}

[numthreads(1, 1, 1)]
void RLTongueDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = gradientAO.b;        
    float4 tongue = float4(SV(diffuse, tongueSaturation, tongueBrightness), 1.0);    
    float4 baseColor = lerp(tongue * rearAO, tongue * frontAO, cavityMask);
    baseColor.a = diffuse.a;

    Result[id.xy] = LinearTosRGB(baseColor);
}

[numthreads(1, 1, 1)]
void RLTongueMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = gradientAO.b;

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessFront, smoothnessMax, mask.a);
    smoothness = lerp(smoothnessRear, smoothness, cavityMask);
    smoothness = pow(saturate(smoothness), smoothnessPower);
    
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLTongueMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = gradientAO.b;

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessFront, smoothnessMax, mask.a);
    smoothness = lerp(smoothnessRear, smoothness, cavityMask);
    smoothness = pow(saturate(smoothness), smoothnessPower);

    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLTongueAO(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 gradientAO = SAMPLE(GradientAO, uv);

    float cavityMask = gradientAO.b;

    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = mask.b;
    float smoothness = lerp(smoothnessFront, smoothnessMax, mask.a);
    smoothness = lerp(smoothnessRear, smoothness, cavityMask);
    smoothness = pow(saturate(smoothness), smoothnessPower);

    float4 packed = float4(ao, ao, ao, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLTongueSubsurface(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 subsurface = float4(tongueSSS.xxx, 1.0) * subsurfaceFalloff * SAMPLE(BaseMap, uv);

    Result[id.xy] = subsurface;
}

[numthreads(1, 1, 1)]
void RLTongueThickness(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 thickness = float4(tongueThickness.xxx, 1.0) * subsurfaceFalloff * SAMPLE(BaseMap, uv);

    Result[id.xy] = thickness;
}


// Eye masks
//
float EyeLimbusMask(float radial)
{
    float inner = limbusDarkRadius * irisScale;
    float outer = limbusDarkWidth * irisScale + inner;
    return smoothstep(inner, outer, radial);
}

float EyeIrisMask(float radial)
{
    float outer = irisRadius * irisScale;
    float inner = outer - limbusWidth * irisScale;
    return smoothstep(inner, outer, radial);
}

float EyePupilScaleMask(float radial)
{
    float scaledDepthRadius = irisRadius * irisScale * depthRadius;
    return saturate(Remap_float(radial, 0, scaledDepthRadius, 1.0, 0.0));
}

float EyeParallaxMask(float radial)
{
    float mask = pow(saturate((parallaxRadius - radial) / parallaxRadius), 0.25);
    return mask;
}

float EyeBlendMask(float radial)
{
    float pr = parallaxRadius * irisScale;
    float lw = limbusWidth * irisScale;

    return smoothstep(pr, pr - lw * 0.5, radial);    
}

float EyeShadowMask(float radial)
{
    return saturate(invLerp(shadowRadius * shadowHardness * scleraScale, shadowRadius * scleraScale, radial));
}


// Eye Bake Kernels
//
[numthreads(1, 1, 1)]
void RLCorneaDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    float2 touv = TilingOffset(uv, scleraScale, float2(0.5, 0.5));
    
    float4 color = SAMPLE(ScleraDiffuse, touv);
    float3 hsv = HSV(color, scleraHue, scleraSaturation, scleraBrightness);
    color = float4(hsv, 1.0);
    float4 colorBlend = SAMPLE(ColorBlend, uv);

    float radial = RADIAL(uv);
    float shadowMask = EyeShadowMask(radial);
    float irisMask = EyeIrisMask(radial);
    color = BlendMultiply_float4(color, sRGBToLinear(cornerShadowColor), shadowMask);

    color = BlendMultiply_float4(color, colorBlend, colorBlendStrength);
    color.a = irisMask;
    
    Result[id.xy] = LinearTosRGB(color);
}

[numthreads(1, 1, 1)]
void RLEyeDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    float2 touv = TilingOffset(uv, irisScale, float2(0.5, 0.5));

    float4 color = SAMPLE(CorneaDiffuse, touv) * sRGBToLinear(irisColor);
    float3 hsv = HSV(color, irisHue, irisSaturation, irisBrightness);
    color = float4(hsv, 1.0);
    float4 colorBlend = SAMPLE(ColorBlend, uv);
    
    float radial = RADIAL(uv);
    float limbusMask = EyeLimbusMask(radial);
    color = color + (sRGBToLinear(irisCloudyColor) * 0.5);
    color = lerp(color, color * sRGBToLinear(limbusColor), limbusMask);    

    color = BlendMultiply_float4(color, colorBlend, colorBlendStrength);
    color.a = 1.0;

    Result[id.xy] = LinearTosRGB(color);
}

[numthreads(1, 1, 1)]
void RLCorneaSingleDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);
    float2 touvCornea = TilingOffset(uv, irisScale, float2(0.5, 0.5));
    float2 touvSclera = TilingOffset(uv, scleraScale, float2(0.5, 0.5));

    float4 cornea = SAMPLE(CorneaDiffuse, touvCornea) * sRGBToLinear(irisColor);
    float3 hsv = HSV(cornea, irisHue, irisSaturation, irisBrightness);
    cornea = float4(hsv, 1.0);
   
    float4 sclera = SAMPLE(ScleraDiffuse, touvSclera);
    hsv = HSV(sclera, scleraHue, scleraSaturation, scleraBrightness);
    sclera = float4(hsv, 1.0);
    
    float4 colorBlend = SAMPLE(ColorBlend, uv);    

    float radial = RADIAL(uv);
    float shadowMask = EyeShadowMask(radial);
    float limbusMask = EyeLimbusMask(radial);
    float irisMask = EyeIrisMask(radial);

    cornea = cornea + (sRGBToLinear(irisCloudyColor) * 0.5);
    cornea = lerp(cornea, cornea * sRGBToLinear(limbusColor), limbusMask);
    sclera = lerp(sclera, sclera * sRGBToLinear(cornerShadowColor), shadowMask);
    float4 color = lerp(cornea, sclera, irisMask);

    color = BlendMultiply_float4(color, colorBlend, colorBlendStrength);
    color.a = 1;

    Result[id.xy] = LinearTosRGB(color);
}

[numthreads(1, 1, 1)]
void RLCorneaMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    
    float radial = RADIAL(uv);    
    float irisMask = EyeIrisMask(radial);    
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = irisMask;
    float smoothness = lerp(corneaSmoothness, scleraSmoothness, irisMask);    
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLCorneaDetailMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);

    float radial = RADIAL(uv);
    float irisMask = EyeIrisMask(radial);
    float depthMask = EyePupilScaleMask(radial);
    float parallaxMask = EyeParallaxMask(radial);
    float blendMask = EyeBlendMask(radial);
    float detailMask = irisMask;    
    float4 packed = float4(blendMask, depthMask, parallaxMask, detailMask);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLEyeMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);

    float radial = RADIAL(uv);
    float irisMask = EyeIrisMask(radial);
    float depthMask = EyePupilScaleMask(radial);
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = depthMask;
    float smoothness = lerp(irisSmoothness, scleraSmoothness, irisMask);
    float4 packed = float4(metallic, ao, detailMask, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLCorneaMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);

    float radial = RADIAL(uv);
    float irisMask = EyeIrisMask(radial);
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = irisMask;
    float smoothness = lerp(corneaSmoothness, scleraSmoothness, irisMask);
    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLCorneaAO(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);

    float radial = RADIAL(uv);
    float irisMask = EyeIrisMask(radial);
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = irisMask;
    float smoothness = lerp(corneaSmoothness, scleraSmoothness, irisMask);
    float4 packed = float4(ao, ao, ao, 1.0);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLCorneaThickness(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float radial = RADIAL(uv);
    float invertedIrisMask = 1.0 - EyeIrisMask(radial);

    float4 thickness = invertedIrisMask * thicknessScale;
    thickness.a = 1.0;
    
    Result[id.xy] = thickness;
}

[numthreads(1, 1, 1)]
void RLCorneaSubsurfaceMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float radial = RADIAL(uv);
    float4 baseMap = SAMPLE(BaseMap, uv);
    float irisMask = saturate(1.0 - EyeIrisMask(radial));
    float sssMask = lerp(scleraSubsurfaceScale, irisSubsurfaceScale, irisMask);
    float4 sss = float4(sssMask, sssMask, sssMask, 1.0) * (subsurfaceFalloff * baseMap);    
    sss.a = thicknessScale;
    
    Result[id.xy] = sss;
}

float4 RootEndBlend(float4 baseColor, float rootMask) 
{    
    float modRootMask = lerp(rootMask, 1 - rootMask, invertRootMap);
    float4 color = lerp(float4(1.0, 1.0, 1.0, 0.0), baseColor, baseColorStrength);    
    float4 rootEnd = lerp(sRGBToLinearApprox(rootColor), sRGBToLinearApprox(endColor), modRootMask);
    float globalMask = lerp(rootColorStrength, endColorStrength, modRootMask) * globalStrength;    
    return lerp(color, rootEnd, globalMask);
}

float4 HighlightBlend(float4 color, float idMap, float rootMask, float4 highlightColor, 
                      float3 distribution, float strength, float overlap, float invert)
{
    float lower = smoothstep(distribution.x, distribution.y, idMap);
    float upper = 1.0 - smoothstep(distribution.y, distribution.z, idMap);
    float highlightMask = strength * lerp(lower, upper, step(distribution.y, idMap));
    float invertedRootMask = lerp(rootMask, 1.0 - rootMask, invert);
    float overlappedInvertedRootMask = 1.0 - (invertedRootMask * overlap);
    highlightMask = saturate(highlightMask * overlappedInvertedRootMask * highlightBlend);
    return lerp(color, sRGBToLinearApprox(highlightColor), highlightMask);
}

[numthreads(1, 1, 1)]
void RLHairColoredDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);    

    float4 diffuse = SAMPLE(Diffuse, uv);
    float4 rootMap = SAMPLE(Root, uv);
    float4 idMap = SAMPLE(ID, uv);
    float4 depthBlend = SAMPLE(ColorBlend, uv);
    float4 mask = SAMPLE(Mask, uv);

    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float alpha = pow(saturate((diffuse.a / alphaRemap)), alphaPower);
    
    float4 color = RootEndBlend(diffuse, rootMap.g);
    color = HighlightBlend(color, idMap.g, rootMap.g, highlightAColor, highlightADistribution,
                           highlightAStrength, highlightAOverlapEnd, highlightAOverlapInvert);
    color = HighlightBlend(color, idMap.g, rootMap.g, highlightBColor, highlightBDistribution,
                           highlightBStrength, highlightBOverlapEnd, highlightBOverlapInvert);

    color = color * diffuseStrength;
    color = lerp(color, color * depthBlend, colorBlendStrength);
    color = lerp(color, color * ao, aoOccludeAll);
    
    color = LinearTosRGB(color);
    color.a = alpha;

    Result[id.xy] = color;
}

[numthreads(1, 1, 1)]
void RLHairColoredDiffuseOnly(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float4 rootMap = SAMPLE(Root, uv);
    float4 idMap = SAMPLE(ID, uv);       

    float alpha = diffuse.a;

    float4 color = RootEndBlend(diffuse, rootMap.g);
    color = HighlightBlend(color, idMap.g, rootMap.g, highlightAColor, highlightADistribution,
        highlightAStrength, highlightAOverlapEnd, highlightAOverlapInvert);
    color = HighlightBlend(color, idMap.g, rootMap.g, highlightBColor, highlightBDistribution,
        highlightBStrength, highlightBOverlapEnd, highlightBOverlapInvert);    

    color = LinearTosRGB(color);
    color.a = alpha;

    Result[id.xy] = color;
}

[numthreads(1, 1, 1)]
void RLHairDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 diffuse = SAMPLE(Diffuse, uv);
    float4 depthBlend = SAMPLE(ColorBlend, uv);
    float4 mask = SAMPLE(Mask, uv);    
    
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float alpha = saturate(pow(saturate((diffuse.a / alphaRemap)), alphaPower));
    
    float4 color = diffuse * diffuseStrength;
    color = lerp(color, color * depthBlend, colorBlendStrength);
    color = lerp(color, color * ao, aoOccludeAll * 0.5);
    
    color = LinearTosRGB(color);
    color.a = alpha;

    Result[id.xy] = color;    
}

[numthreads(1, 1, 1)]
void RLHairMask(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 specular = SAMPLE(Specular, uv);
        
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float spec = specular.g;
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = lerp(smoothness, smoothness * ao, aoOccludeAll);
    float4 packed = float4(metallic, ao, spec, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHairMetallicGloss(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    
    float metallic = mask.r;
    float ao = INVERTED_SCALE(mask.g, aoStrength);    
    float smoothness = lerp(smoothnessMin, smoothnessMax, pow(mask.a, smoothnessPower));
    smoothness = lerp(smoothness, smoothness * ao, aoOccludeAll);
    float4 packed = float4(metallic, metallic, metallic, smoothness);

    Result[id.xy] = packed;
}

[numthreads(1, 1, 1)]
void RLHairAO(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);
    float4 specular = SAMPLE(Specular, uv);
    
    float ao = INVERTED_SCALE(mask.g, aoStrength);
    float detailMask = (specular.r + specular.g + specular.b) / 3.0;    
    float4 packed = float4(ao, ao, ao, detailMask);

    Result[id.xy] = packed;
}

float EyeOcclusionGradient(float2 uv)
{
    float x = uv.x;
    float y = uv.y;
    float right = smoothstep(eoInnerMin, eoInnerMax, 1 - x);
    float left = smoothstep(eoOuterMin, eoOuterMax, x);
    float top = pow(smoothstep(eoTopMin, eoTopMax, 1 - y), eoTopCurve);
    float bottom = pow(smoothstep(eoBottomMin, eoBottomMax, y), eoBottomCurve);
    float alpha1 = saturate((1.0 - saturate(8.0 * right * left * top * bottom)) * eoOcclusionStrength);
    float alpha2 = saturate(smoothstep(eoTop2Min, eoTop2Max, y) * eoOcclusionStrength2);
    float edge2 = ((1.0 - eoTearDuctPosition) * eoTearDuctWidth) + eoTearDuctPosition;
    float tearDuctMask = (1.0 - smoothstep(eoTearDuctPosition, edge2, x));
    return pow(saturate(max(alpha1, alpha2) * tearDuctMask), eoOcclusionPower);
}

[numthreads(1, 1, 1)]
void RLEyeOcclusionDiffuse(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 alpha = EyeOcclusionGradient(uv);
    //float4 color = sRGBToLinearApprox(eoEyeOcclusionColor);
    // premultiply
    float4 color = eoEyeOcclusionColor * alpha;    

    Result[id.xy] = color;
}

[numthreads(1, 1, 1)]
void RLFlowToNormal(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 flow = SAMPLE(Flow, uv);    

    float3 flowVector = normalize(flow.rgb * 2.0 - 1.0);
    flow.y = lerp(flow.y, -flow.y, tangentFlipY);
    float3 tangentPlane = normalize(float3(-flowVector.y, flowVector.x, 0.0));
    float3 normal = cross(flowVector, tangentPlane);
    float3 modified = normalize(float3(normal.xy * 0.35, normal.z));
    float4 color = float4(saturate(modified.xyz * 0.5 + 0.5), 1.0);

    Result[id.xy] = color;
}

[numthreads(1, 1, 1)] 
void RLHDRPCorrected(uint3 id : SV_DispatchThreadID)
{
    float2 uv = GetUV(id.xy);

    float4 mask = SAMPLE(Mask, uv);    
    float detail = SAMPLE(Detail, uv).g;
    mask.b = sqrt(detail);

    Result[id.xy] = mask;
}




